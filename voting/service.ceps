kind Event;
Event evDoVote;
Event evAddEntry;
Event evEntryNotFound;
Event evVoteProcessedSuccessfully;
Event evAddEntryProcessedSuccessfully;
Event evAddEntryTableFull;
Event evAddEntryEntryExists;

val max_voting_table_size = 10;
val msg_buffer_size_in_dwords = 64;
val table_item_key_ofs = 0;
val table_item_vote_ofs = 4;

OblectamentaDataLabel voting_table_size;
OblectamentaDataLabel voting_table;
oblectamenta{global{data{  // here are the global data definitions
    msg_buffer;
    comment{"Reserve space for the message buffer.";};
    for(i : 1 .. msg_buffer_size_in_dwords) {0;}
    comment{"Reserve space for the table' size and initialize with 0 (0 entries in table)";};
    voting_table_size; 1;
    voting_table;comment{"Reserve space for the table itself.";};
    TABLE_ENTRY{3;4;};  
    for(i : 2 .. max_voting_table_size ){ 
        TABLE_ENTRY{0;0;};
    }
 };};};

sm{
 HandleVote;
 states{Initial; ReadyForRequest; ProcessRequest;Error;};
 Actions{
    doProcessRequest{
     oblectamenta{text{asm{
        OblectamentaCodeLabel loop_search_entry, loop_search_entry_failed, loop_search_entry_success;      
        val key = R0;
        val votes = R1;
        val table_size = R2;
        val current_idx = R3;
        val addr_current_element = R4;  
        msg_match{
         {
            Key{
                i32 # "A int 32 value";
                sti32(key) # "store int 32 value in key";
            };
            Vote{
                i32 # "A int 32 value";
                sti32(votes) # "store int 32 value in key";
            };
         }
        };
        ldi32(0); // Put 0 as 32 bit signed integer on the top of the computation stack
        sti32(current_idx); //current_idx = 0
        
        lea(voting_table_size); // Top(computestack) = address of voting_table_size 
        ldsi32;                 // Top(computestack) = value at voting_table_size
        sti32(table_size);      // table_size = number of elements in table

        // Find entry.
        
    loop_search_entry;
        ldi32(current_idx);
        ldi32(table_size);
        blteq(loop_search_entry_failed); //If table_idx >= table_size jump to loop_search_entry_failed; 
        lea(voting_table);
        ldi32(current_idx);
        ldi32(table_entry_size);
        muli32;
        ui32toui64;
        addi64;
        sti64(addr_current_element);
        ldi64(addr_current_element);
        ldi64(table_item_key_ofs);
        addi64;
        ldsi32;
        ldi32(key);
        beq(loop_search_entry_success);
        ldi32(current_idx);
        ldi32(1);
        addi32;
        sti32(current_idx);
        buc(loop_search_entry);
        buc(loop_search_entry_success);
        loop_search_entry_failed;
        evEntryNotFound;
        halt;
    loop_search_entry_success;
        ldi64(addr_current_element);
        ldi64(table_item_vote_ofs);
        addi64;
        ldsi32;
        ldi32(votes);
        addi32;
        ldi64(addr_current_element);
        ldi64(table_item_vote_ofs);
        addi64;
        stsi32;
        evVoteProcessedSuccessfully;
        halt;
     };};};
    };
 };
 t{Initial;ReadyForRequest;};
 t{ReadyForRequest;ProcessRequest;evDoVote;};
 t{ProcessRequest;ReadyForRequest;doProcessRequest;};
};

sm{
    HandleEntries;
    Actions{
        doAddEntry{
            oblectamenta{text{asm{
                OblectamentaCodeLabel 
                  add_entry_loop_search_entry, add_entry_loop_search_entry_failed, add_entry_loop_search_entry_success, add_entry_tbl_full;
                //evAddEntryProcessedSuccessfully;
                val key = R0;
                val table_size = R2;
                val current_idx = R3;
                val addr_current_element = R4;  
                msg_match{
                {
                 Key{
                  i32 # "A int 32 value";
                  sti32(key) # "store int 32 value in key";
                 };
                 }
                };
                ldi32(0);                                   // Put 0 as 32 bit signed integer on the top of the computation stack
                sti32(current_idx);                         //current_idx = 0
        
                lea(voting_table_size);            // Put the address of voting_table_size onto the computestack 
                ldsi32;                 // Pop the address on top of the compute stack and push the value references onto the compute stack
                sti32(table_size);      // Put the constant table_size onto the compute stack
                // Search a free field.
                // Check whether the table is already full 
                ldi32(table_size);     // Put the i32 value stored in the register denoted by table_size onto the compute stack
                ldi32(max_voting_table_size); // Put the value of the i32 constant max_voting_table_size onto the compute stack
                blteq(add_entry_tbl_full); // Jump to add_entry_tbl_full if max_voting_table_size <= table_size 

        
               add_entry_loop_search_entry; // This is a label, labels serve as destination for jumps

                ldi32(current_idx);                         // Put the i32 value current_idx which denotes a register onto the compute stack
                ldi32(table_size);                          // Put the i32 value table_size which denotes a register onto the compute stack
                blteq(add_entry_loop_search_entry_failed);  // If table_idx >= table_size jump to loop_search_entry_failed; 
                lea(voting_table);                          // Put the address of voting_table onto the compute stack
                ldi32(current_idx);                         // Put the value of the register denoted by current_idx onto the compute stack
                ldi32(table_entry_size);                    // Put the i32 constant value of table_entry_size onto the compute stack
                muli32;                                     // Multiply the top i32 elements on the compute stack and replace them with the result, which is current_idx*table_entry_size
                ui32toui64;                                 // Convert the top i32 value into a unsigned integer of 64 width capable of holding an address
                addi64;                                     // Add the top i64 values on the compute stack and replace them with the result
                sti64(addr_current_element);                // Store the top value of the computation stack in the register denoted by addr_current_element
                ldi64(addr_current_element);                // Put the i64 value which is in the register denoted by addr_current_element onto the computation stack
                ldi64(table_item_key_ofs);                  // Put the constant value table_item_key_ofs as i64 value onto the compute stack
                addi64;                                     // add the top i64 elements of the compute stack and replace them with the result
                ldsi32;                                     // The address at the top of the compute stack points to the current element's key, derefernce the address and replace it with the i32 value.
                ldi32(key);                                 // Put the i32 value stored in the register denoted by key onto the compute stack
                beq(add_entry_loop_search_entry_success);   // If the top two i32 values on the compute stack are equal jump to add_entry_loop_search_entry_success
                ldi32(current_idx);                         // Put the vaue in register denoted by current_idx onto the compute stack
                ldi32(1);                                   // Put the i32 representation of the value 1 onto the compute stack
                addi32;                                     // Add the top two values on the compute stack and replace them with the result
                sti32(current_idx);                         // Put the top i32 value on the compute stack into the register denoted by current_idx
                buc(add_entry_loop_search_entry);           // Jump to add_entry_loop_search_entry, buc means 'branch unconditionally' 
                buc(add_entry_loop_search_entry_success);   // Jump to add_entry_loop_search_entry_success, buc means 'branch unconditionally'
               add_entry_loop_search_entry_failed;          // This is a label, labels serve as destination for jumps
                                                            // Invariant: current_idx points to the next free entry
                lea(voting_table);                          // Puts address of voting_table on top of the computaton stack
                ldi32(current_idx);                         // Puts the content of the register with alias current_idx on top of the computation stack
                ldi32(table_entry_size);                    // Puts the constant table_entry_size on top of the computation stack
                muli32;                                     // Multiplies the top two i32 values on the computation stack and replaces them with the i32 result, i.e. the computation stack shrinks by 4 bytes.
                ui32toui64;                                 // Convert top i32 element of compute stack into an i64 value
                addi64;                                     // Add the top two i64 elements and replace them with the result
                sti64(addr_current_element);                // Move the i64 on top of the computation stack into the register aliased by addr_current_element
                ldi32(key);                                 // Copy the value in register aliased with key on top of the computation stack
                ldi64(addr_current_element);                // Copy the value of the register which holds addr_current_element on top of the computation stack
                ldi64(table_item_key_ofs);                  // Copy the i64 representation of the constant value table_item_key_ofs onto the compute stack
                addi64;                                     // Add the top two elements of the compute stack and replace them with the result.
                stsi32;                                     // sets the key field of the entry's table entry
                ldi32(0);                                   // put the 32 bit signed integer representation of the value 0 onto the compute stack
                ldi64(addr_current_element);                // Copy the value of the register aliased with addr_current_element onto the compute stack
                ldi64(table_item_vote_ofs);                 // Copy the constant value table_item_vote_ofs as a 64 bit wide integer onto the top of the compute stack
                addi64;                                     // Add the top two i64 values on the compute stack and replace them with the result
                stsi32;                                     // sets the key field of the entry's table entry
                ldi32(current_idx);
                ldi32(1);
                addi32;
                lea(voting_table_size);
                stsi32;                                   // Update variable referenced by voting_table_size by incrementing it 
                evAddEntryProcessedSuccessfully;            // Fire event evAddEntryProcessedSuccesfully
                halt;                                       // Stop execution
               add_entry_tbl_full;
                evAddEntryTableFull;                        // Table is full, we signal this by firing the event evAddEntryTableFull
                halt;                                       // Stop execution
               add_entry_loop_search_entry_success;
                evAddEntryEntryExists;                      // Search found an entry with the requested key, fire an according event
                halt;
            };};};
        };
    };
    states{Initial;ReadyForRequest;ProcessRequest;};
    t{Initial;ReadyForRequest;};
    t{ReadyForRequest;ProcessRequest;evAddEntry;doAddEntry;};
    t{ProcessRequest;ReadyForRequest;};   
};

sm{
 ExampleClients;
 states{Initial;};
 sm{
  ExampleClientDoesVote;
  states{Initial;SendRequest;RequestSent;ErrorReceivedEntryDoesntExist;VoteProcessedSuccessfully;};
  Actions{
   doSendRequest{
   oblectamenta{text{asm{ 
    send_msg{evDoVote;{Key{ldi32(3);i32;};Vote{ldi32(2);i32;};}};
   };};};
   };
  };
  t{Initial;SendRequest;};
  t{SendRequest;RequestSent;doSendRequest;};
  t{RequestSent;ErrorReceivedEntryDoesntExist;evEntryNotFound;};
  t{RequestSent;VoteProcessedSuccessfully;evVoteProcessedSuccessfully;};
 };
 sm{
  ExampleClientDoesAddEntry;
  states{Initial;SendRequest;RequestSent;ErrorReceivedTableFull;ErrorReceivedEntryDoesExist;AddEntryProcessedSuccessfully;};
  Actions{
  doSendRequest{
   oblectamenta{text{asm{ 
    send_msg{evAddEntry;{Key{ldi32(42);i32;};}};
   };};};
  };
  };
  t{Initial;SendRequest;};
  t{SendRequest;RequestSent;doSendRequest;};
  t{RequestSent;ErrorReceivedTableFull;evAddEntryTableFull;};
  t{RequestSent;ErrorReceivedEntryDoesExist;evAddEntryEntryExists;};
  t{RequestSent;AddEntryProcessedSuccessfully;evAddEntryProcessedSuccessfully;};
 };
 
 t{Initial;ExampleClientDoesVote;};
 t{ExampleClientDoesVote.VoteProcessedSuccessfully;ExampleClientDoesAddEntry;};
};

Simulation{
    Start{HandleVote;HandleEntries;ExampleClients;};
};