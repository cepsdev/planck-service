/*
A Planckservice - smallest possible microservice.
Implemented using state machines with actions written in Oblectamenta Assembler.
*/

kind Event;                                    //You can now write Event MyEvent, and MyEvent is known to be a special 'thing' associated with Event
kind Guard;                                    // Guards for transitions, again you can now write Guard myguard;


kind OblectamentaMsgDefDirective;              // Is used in connection with the serialization of messages
kind OblectamentaMsgReadDirective;             // Is used in connection with the deserialization of messages
kind OblectamentaMessageModifier;              // Indicates flags modifying the standad behaviour of serialization/deserialization of messages

OblectamentaMessageTag i32;                    // Used when writing/reading message fields which contain 32 bit integers
OblectamentaMessageTag i64;                    // Used when writing/reading message fields which contain 64 bit integers
OblectamentaMessageTag f64;                    // Used when writing/reading message fields which contain 64 bit floats (IEE 754)
OblectamentaMessageTag sz;                     // ... zero terminated strings
OblectamentaMessageModifier all;               // This one let you iterate over all fields of a given name

OblectamentaMsgDefDirective write;             // Indicates the serialization of a message
OblectamentaMsgReadDirective read;             // ... deserialization ...
   
OblectamentaDataLabel msg_buffer,msg_buffer_reply, accounts, 
                      pi,nl,count, client_count, event_header;     // Data labels mark the location of data in the global data segment

kind OblectamentaGlobalEventPayload; 
OblectamentaGlobalEventPayload global_payload_buffer;
kind OblectamentaGlobalEventMetainformation;
OblectamentaGlobalEventMetainformation global_event_header_buffer;

Event evAddAccount, evReplyOK, 
      evReplyNOKTableFull, evPrintTable;       //A couple of events used in transitions of state machines 

val max_accounts = 32;                         // val introduces a value which is computed beforehand, i.e. during compilation
val entry_len = 16;
val offs_a = 0;
val offs_b = 8;
val max_client_requests = 12;


oblectamenta{ 
 global{
   data{                                       // here are the global data definitions
    msg_buffer_reply; 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
    0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;

    count; 0;                                  // count is the name of the location which contains a 32 bit integer with value 0 (all bits are 0)
    accounts; for (e: 1 .. max_accounts){0;0;} // reserves max_accounts of two consecutive 32 bit integers initialized with 0
                                               // for (...) {...} is evaluated during AST expansion, i.e. is a program transformation (meta programming)

    msg_buffer;global_payload_buffer; for(e : 1 .. 64) {0;}          // Reserve 32 consecutively stored 32 bit integers initialized to the value 0
    client_count;0;                            // 32 bit integer initialized with 0
    event_header;global_event_header_buffer;for(e : 1 .. 32) {0;}
    pi;3.14159265;
   };
 };
};


             
sm{                                            // Our service is modeled as a state machine
    Service;                                   // Name of the state machine
    states{Initial;Ready;ProcessRequest;};     // Atomic states 
    Actions{                                   // Actions are triggered in transitions
        doAddAccount{ 
         oblectamenta{text{asm{                   // yeah, a lot of typing to indicate an assemble routine 
           OblectamentaCodeLabel lbl_table_full;  // We will do a goto and need a label (this is the declaration)
           
           lea(count);                            // The Oblectamenta VM implements a hybrid (virtual-)machine architecture, it has plenty of registers and also a compute stack.
                                                  // lea(count) puts the address of the object labeled count on the top of the compute stack, hence
                                                  // CS = |&count| (we use the C address of operator &) 
           ldsi32;                                // Dereference the pointer on the top of CS and push the i32 value on CS
                                                  // addr =TOP(CS); value = *(int32_t*)addr; CS = |value of count|
           ldi32(max_accounts);                   // max_accounts is a constant value, ldi32 pushes the max_accounts on CS
                                                  // CS = |value of count|max_accounts|

           blteq(lbl_table_full);                 // a = pop 32 bit value from CS
                                                  // b = pop 32 bit value from CS
                                                  // (CS empty now)
                                                  // if b <= a jump to lbl_table_full
                                   
           lea(count);ldsi32;ldi32(entry_len);muli32;sti32(R0); // R0 = count * entry_len;
           lea(count);ldsi32;ldi32(1);addi32;lea(count);stsi32; // count = count + 1
           lea(accounts);ldi64(R0);addi64;sti64(R1);            // R1 = &accounts + R0 = &accounts[count-1]
           assert_empty_cs;
           
           msg{                                 // msg{...} is NOT a machine language instruction of any kind, msg is a directive which gets
                                                // translated into an Oblectamenta fragment which allows for a compact notation of message serialization/deserialization
                read;                           // Indicates that code for deserialization has to be generated
                msg_buffer;
                { // A scope introduces a node with no name, 
                  // which is represented as an object in JSON
                  Account{                        // The first element of the message is an Account, this innocuous looking struct is translated in a lengthy code fragment
                                                // which handles the correct deserialization of a node with the name Account and a variable number of sub nodes.
                    {   //Scope => object in JSON
                     a{                          // Account.a
                        f64;                    // Read a 32 bit signed integer, we denote its value with a
                        ldi64(offs_a);          // |
                        ldi64(R1);              // |
                        addi64;                 // |
                        stsi64;                 // ===> Accounts[count-1].a = a
                     };
                     b{                         // Account.b
                        f64;                   // Read a 32 bit signed integer, we denote its value with b
                        ldi64(offs_b);         // |
                        ldi64(R1);             // |
                        addi64;                // |
                        stsi64;                // ===> Accounts[count-1].b = b
                     };
                    }
                 }; //Account
                }
            };
            msg{ // Each message comes with a orignin field, we read it to build our destination
              read;
              msg_buffer;
              origin_websocket_sock{ // Will only be matched if it exists
                i32;
                sti32(R2);           
              };  
            };
            evReplyOK(  // we trigger an event with a payload
            msg{
                write;
                msg_buffer_reply;
                destination_websocket_sock{ //assuming that the client lives behind a websocket connection
                  ldi32(R2);
                  i32;
                };
                {
                  reply{
                    lea(pi);
                    ldsi64;
                    f64;
                  };
                }
              }
            );
            halt;                    // Reply with the event evReplyOK and stop
            lbl_table_full;evReplyNOKTableFull; // We end up here if and only if the table is full, we reply by sending the event evReplyNOKTableFull
         };};};
        };
    };
    t{Initial;Ready;};                         // state machine transitions immediately to the state Ready
    t{Ready;ProcessRequest;evAddAccount;doAddAccount;}; // We loop on Ready, each time we receive an event evAddAccount we add an account (assuming the message's payload is in msg_buffer)
    t{ProcessRequest;Ready;};
};

sm{
  S;
  states{Initial;Ping;Pong;};
  t{Initial;Ping;};
  t{Ping;Pong;evReplyOK;};
  t{Pong;Ping;};
};

Simulation{
    Start{Service;S;};
};
